import { promises as fs, readFileSync } from 'fs';
import { basename, normalize } from 'path';

import {
  assert,
  assertIsArray,
} from '@jarvis-network/core-utils/dist/base/asserts';

import {
  mkAbiJsonExport,
  mkExportTypeAlias,
  mkExportTypesFrom,
  mkImport,
  mkImports,
  mkUnionType,
  TypeImport,
} from './mk-code';

export async function writeHeaderFile(
  dir: string,
  headerGenParams: HeaderGenParams,
): Promise<void> {
  const path = normalize(dir);
  const files = await fs.readdir(dir);
  const entries = files
    .filter(f => basename(f) !== 'index.ts')
    .map(f => normalize(`${dir}/${f}`));
  if (entries.length !== files.length) {
    console.log(`'${path}/index.ts' exists - overwriting.`);
  }
  const headerContent = generateHeader(entries, headerGenParams);
  await fs.writeFile(`${path}/index.ts`, headerContent, 'utf-8');
}

interface HeaderGenParams {
  ext: string;
  unionName?: string;
  unionTypeMapFun?: (type: string) => string;
  imports?: TypeImport[];
}

function generateHeader(
  typePaths: string[],
  { ext, unionName, unionTypeMapFun, imports }: HeaderGenParams,
) {
  const names: string[] = typePaths.map(p => stripExt(basename(p), ext));
  let output =
    '/* File autogenerated by synthereum-lib. Do not edit manually. */\n' +
    '/* eslint-disable */\n\n';

  output += mkImports(imports ?? []);

  if (unionName && unionName.length > 0)
    output += `${mkUnionType(
      unionName,
      names.filter(n => n !== 'types').map(unionTypeMapFun ?? (x => x)),
    )}\n`;

  output += typePaths
    .map((filepath, i) => {
      const name = names[i];
      return ext !== '.json'
        ? generateDTsImport(filepath, name)
        : shouldGenerateAbiJsonImport(filepath)
        ? mkAbiJsonExport(name)
        : '';
    })
    .filter(x => x.length)
    .join('\n');
  return output;
}

function generateDTsImport(filename: string, name: string): string {
  assert(
    filename.slice(-5) === '.d.ts',
    `Expected '.d.ts' file extension, but got filename: '${filename}'`,
  );
  const allExportedSymbols = getAllModuleExports(filename);

  // Specially handle the `types.d.ts` file:
  if (name === 'types') {
    return mkExportTypesFrom(allExportedSymbols, './types');
  }

  const auxiliaryTypes = allExportedSymbols.filter(t => t !== name);

  let result =
    mkImport({ module: `./${name}`, types: [name] }) +
    mkExportTypesFrom([name]);

  if (auxiliaryTypes.length) {
    const importedAsTypes = auxiliaryTypes.map(t => `${t} as ${name}_${t}`);
    const exportTypes = auxiliaryTypes
      .map(t => `  ${mkExportTypeAlias(t, `${name}_${t}`)}`)
      .join('');

    result += `${mkImport({
      module: `./${name}`,
      types: importedAsTypes,
    })}export namespace ${name}_Events {\n${exportTypes}}\n`;
  }

  return result;
}

export function getAllModuleExports(moduleFileName: string): string[] {
  const ts = readFileSync(moduleFileName, 'utf-8');
  return [...ts.matchAll(/export [\w]+? ([\w].+?)[ <]/g)].map(x => x[1]);
}

function shouldGenerateAbiJsonImport(filename: string) {
  const json = JSON.parse(readFileSync(filename, 'utf-8'));
  return assertIsArray(json.abi).length > 0;
}

/**
 * Strips `ext` from the end of `fileName` while asserting that `fileName` ends with `ext`.
 */
function stripExt(fileName: string, ext: string) {
  assert(ext.length < fileName.length, 'File name too short');
  assert(
    fileName.slice(-ext.length) === ext,
    `File name '${fileName}' doesn't end with extension '${ext}'`,
  );
  return fileName.slice(0, fileName.length - ext.length);
}
