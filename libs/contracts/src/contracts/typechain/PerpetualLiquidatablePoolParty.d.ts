/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "./types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export type Deposit = ContractEventLog<{
  sponsor: string;
  collateralAmount: string;
  0: string;
  1: string;
}>;
export type DisputeSettled = ContractEventLog<{
  caller: string;
  sponsor: string;
  liquidator: string;
  disputer: string;
  liquidationId: string;
  disputeSucceeded: boolean;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
  5: boolean;
}>;
export type EmergencyShutdown = ContractEventLog<{
  caller: string;
  shutdownTimestamp: string;
  0: string;
  1: string;
}>;
export type EndedSponsorPosition = ContractEventLog<{
  sponsor: string;
  0: string;
}>;
export type FinalFeesPaid = ContractEventLog<{
  amount: string;
  0: string;
}>;
export type LiquidationCreated = ContractEventLog<{
  sponsor: string;
  liquidator: string;
  liquidationId: string;
  tokensOutstanding: string;
  lockedCollateral: string;
  liquidatedCollateral: string;
  liquidationTime: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
  5: string;
  6: string;
}>;
export type LiquidationDisputed = ContractEventLog<{
  sponsor: string;
  liquidator: string;
  disputer: string;
  liquidationId: string;
  disputeBondAmount: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
}>;
export type LiquidationWithdrawn = ContractEventLog<{
  caller: string;
  paidToLiquidator: string;
  paidToDisputer: string;
  paidToSponsor: string;
  liquidationStatus: string;
  settlementPrice: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
  5: string;
}>;
export type NewSponsor = ContractEventLog<{
  sponsor: string;
  0: string;
}>;
export type PositionCreated = ContractEventLog<{
  sponsor: string;
  collateralAmount: string;
  tokenAmount: string;
  0: string;
  1: string;
  2: string;
}>;
export type Redeem = ContractEventLog<{
  sponsor: string;
  collateralAmount: string;
  tokenAmount: string;
  0: string;
  1: string;
  2: string;
}>;
export type RegularFeesPaid = ContractEventLog<{
  regularFee: string;
  lateFee: string;
  0: string;
  1: string;
}>;
export type Repay = ContractEventLog<{
  sponsor: string;
  numTokensRepaid: string;
  newTokenCount: string;
  0: string;
  1: string;
  2: string;
}>;
export type RequestWithdrawal = ContractEventLog<{
  sponsor: string;
  collateralAmount: string;
  0: string;
  1: string;
}>;
export type RequestWithdrawalCanceled = ContractEventLog<{
  sponsor: string;
  collateralAmount: string;
  0: string;
  1: string;
}>;
export type RequestWithdrawalExecuted = ContractEventLog<{
  sponsor: string;
  collateralAmount: string;
  0: string;
  1: string;
}>;
export type RoleAdminChanged = ContractEventLog<{
  role: string;
  previousAdminRole: string;
  newAdminRole: string;
  0: string;
  1: string;
  2: string;
}>;
export type RoleGranted = ContractEventLog<{
  role: string;
  account: string;
  sender: string;
  0: string;
  1: string;
  2: string;
}>;
export type RoleRevoked = ContractEventLog<{
  role: string;
  account: string;
  sender: string;
  0: string;
  1: string;
  2: string;
}>;
export type SettleEmergencyShutdown = ContractEventLog<{
  caller: string;
  collateralReturned: string;
  tokensBurned: string;
  0: string;
  1: string;
  2: string;
}>;
export type Withdrawal = ContractEventLog<{
  sponsor: string;
  collateralAmount: string;
  0: string;
  1: string;
}>;

export interface PerpetualLiquidatablePoolParty extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): PerpetualLiquidatablePoolParty;
  clone(): PerpetualLiquidatablePoolParty;
  methods: {
    DEFAULT_ADMIN_ROLE(): NonPayableTransactionObject<string>;

    POOL_ROLE(): NonPayableTransactionObject<string>;

    /**
     * Add admin to DEFAULT_ADMIN_ROLE
     * @param admin address of the Admin.
     */
    addAdmin(admin: string): NonPayableTransactionObject<void>;

    /**
     * Add admin and pool to DEFAULT_ADMIN_ROLE and POOL_ROLE
     * @param adminAndPool address of admin/pool.
     */
    addAdminAndPool(adminAndPool: string): NonPayableTransactionObject<void>;

    /**
     * Add TokenSponsor to POOL_ROLE
     * @param pool address of the TokenSponsor pool.
     */
    addPool(pool: string): NonPayableTransactionObject<void>;

    /**
     * Add derivative as admin of synthetic token
     * @param derivative address of the derivative
     */
    addSyntheticTokenAdmin(
      derivative: string
    ): NonPayableTransactionObject<void>;

    /**
     * Add derivative as admin, minter and burner of synthetic token
     * @param derivative address of the derivative
     */
    addSyntheticTokenAdminAndMinterAndBurner(
      derivative: string
    ): NonPayableTransactionObject<void>;

    /**
     * Add derivative as burner of synthetic token
     * @param derivative address of the derivative
     */
    addSyntheticTokenBurner(
      derivative: string
    ): NonPayableTransactionObject<void>;

    /**
     * Add derivative as minter of synthetic token
     * @param derivative address of the derivative
     */
    addSyntheticTokenMinter(
      derivative: string
    ): NonPayableTransactionObject<void>;

    /**
     * Cancels a pending withdrawal request.
     */
    cancelWithdrawal(): NonPayableTransactionObject<void>;

    /**
     * Gets the collateral currency of the derivative
     */
    collateralCurrency(): NonPayableTransactionObject<string>;

    create(
      collateralAmount: [number | string],
      numTokens: [number | string]
    ): NonPayableTransactionObject<void>;

    /**
     * Delete liquidation of a TokenSponsor psoition (This function can only be called by the contract itself)
     * @param sponsor address of the TokenSponsor.
     */
    deleteSponsorPosition(sponsor: string): NonPayableTransactionObject<void>;

    deposit(
      collateralAmount: [number | string]
    ): NonPayableTransactionObject<void>;

    depositTo(
      sponsor: string,
      collateralAmount: [number | string]
    ): NonPayableTransactionObject<void>;

    /**
     * Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`. Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal to occur via the `settleEmergencyShutdown` function.
     * Premature contract settlement under emergency circumstances.
     */
    emergencyShutdown(): NonPayableTransactionObject<void>;

    /**
     * Get the price of synthetic token set by DVM after emergencyShutdown call
     */
    emergencyShutdownPrice(): NonPayableTransactionObject<[string]>;

    feePayerData(): NonPayableTransactionObject<{
      collateralCurrency: string;
      finder: string;
      lastPaymentTime: string;
      cumulativeFeeMultiplier: [string];
      0: string;
      1: string;
      2: string;
      3: [string];
    }>;

    /**
     * Accessor method for the list of member with admin role
     */
    getAdminMembers(): NonPayableTransactionObject<string[]>;

    /**
     * This is necessary because the struct returned by the positions() method shows rawCollateral, which isn't a user-readable value.
     * Accessor method for a sponsor's collateral.
     * @param sponsor address whose collateral amount is retrieved.
     */
    getCollateral(sponsor: string): NonPayableTransactionObject<[string]>;

    /**
     * Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp.
     */
    getCurrentTime(): NonPayableTransactionObject<string>;

    /**
     * Accessor method for the list of member with pool role
     */
    getPoolMembers(): NonPayableTransactionObject<string[]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: string | number[]): NonPayableTransactionObject<string>;

    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    getRoleMember(
      role: string | number[],
      index: number | string
    ): NonPayableTransactionObject<string>;

    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    getRoleMemberCount(
      role: string | number[]
    ): NonPayableTransactionObject<string>;

    globalPositionData(): NonPayableTransactionObject<{
      totalTokensOutstanding: [string];
      rawTotalPositionCollateral: [string];
      0: [string];
      1: [string];
    }>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: string | number[],
      account: string
    ): NonPayableTransactionObject<void>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: string | number[],
      account: string
    ): NonPayableTransactionObject<boolean>;

    liquidatableData(): NonPayableTransactionObject<{
      rawLiquidationCollateral: [string];
      liquidationLiveness: string;
      collateralRequirement: [string];
      disputeBondPct: [string];
      sponsorDisputeRewardPct: [string];
      disputerDisputeRewardPct: [string];
      0: [string];
      1: string;
      2: [string];
      3: [string];
      4: [string];
      5: [string];
    }>;

    liquidations(
      arg0: string,
      arg1: number | string
    ): NonPayableTransactionObject<{
      sponsor: string;
      liquidator: string;
      state: string;
      liquidationTime: string;
      tokensOutstanding: [string];
      lockedCollateral: [string];
      liquidatedCollateral: [string];
      rawUnitCollateral: [string];
      disputer: string;
      settlementPrice: [string];
      finalFee: [string];
      0: string;
      1: string;
      2: string;
      3: string;
      4: [string];
      5: [string];
      6: [string];
      7: [string];
      8: string;
      9: [string];
      10: [string];
    }>;

    payFinalFees(
      payer: string,
      amount: [number | string]
    ): NonPayableTransactionObject<void>;

    /**
     * These must be paid periodically for the life of the contract. If the contract has not paid its regular fee in a week or more then a late penalty is applied which is sent to the caller. If the amount of fees owed are greater than the pfc, then this will pay as much as possible from the available collateral. An event is only fired if the fees charged are greater than 0.
     * Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.
     */
    payRegularFees(): NonPayableTransactionObject<[string]>;

    /**
     * This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.
     * Gets the current profit from corruption for this contract in terms of the collateral currency.
     */
    pfc(): NonPayableTransactionObject<[string]>;

    positionManagerData(): NonPayableTransactionObject<{
      tokenCurrency: string;
      priceIdentifier: string;
      withdrawalLiveness: string;
      minSponsorTokens: [string];
      emergencyShutdownPrice: [string];
      emergencyShutdownTimestamp: string;
      excessTokenBeneficiary: string;
      0: string;
      1: string;
      2: string;
      3: [string];
      4: [string];
      5: string;
      6: string;
    }>;

    positions(
      arg0: string
    ): NonPayableTransactionObject<{
      tokensOutstanding: [string];
      withdrawalRequestPassTimestamp: string;
      withdrawalRequestAmount: [string];
      rawCollateral: [string];
      0: [string];
      1: string;
      2: [string];
      3: [string];
    }>;

    redeem(numTokens: [number | string]): NonPayableTransactionObject<[string]>;

    /**
     * This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.
     * Theoretically supposed to pay fees and move money between margin accounts to make sure they reflect the NAV of the contract. However, this functionality doesn't apply to this contract.
     */
    remargin(): NonPayableTransactionObject<void>;

    /**
     * Admin renounce to DEFAULT_ADMIN_ROLE
     */
    renounceAdmin(): NonPayableTransactionObject<void>;

    /**
     * Admin and TokenSponsor pool renounce to DEFAULT_ADMIN_ROLE and POOL_ROLE
     */
    renounceAdminAndPool(): NonPayableTransactionObject<void>;

    /**
     * TokenSponsor pool renounce to POOL_ROLE
     */
    renouncePool(): NonPayableTransactionObject<void>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: string | number[],
      account: string
    ): NonPayableTransactionObject<void>;

    /**
     * This contract renounce to be admin of synthetic token
     */
    renounceSyntheticTokenAdmin(): NonPayableTransactionObject<void>;

    /**
     * This contract renounce to be admin, minter and burner of synthetic token
     */
    renounceSyntheticTokenAdminAndMinterAndBurner(): NonPayableTransactionObject<void>;

    /**
     * This contract renounce to be burner of synthetic token
     */
    renounceSyntheticTokenBurner(): NonPayableTransactionObject<void>;

    /**
     * This contract renounce to be minter of synthetic token
     */
    renounceSyntheticTokenMinter(): NonPayableTransactionObject<void>;

    repay(numTokens: [number | string]): NonPayableTransactionObject<void>;

    requestWithdrawal(
      collateralAmount: [number | string]
    ): NonPayableTransactionObject<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: string | number[],
      account: string
    ): NonPayableTransactionObject<void>;

    /**
     * Will revert if not running in test mode.
     * Sets the current time.
     * @param time timestamp to set current Testable time to.
     */
    setCurrentTime(time: number | string): NonPayableTransactionObject<void>;

    /**
     * This burns all tokens from the caller of `tokenCurrency` and sends back the resolved settlement value of `feePayerData.collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.This contract must have the Burner role for the `tokenCurrency`.Note that this function does not call the updateFundingRate modifier to update the funding rate as this function is only called after an emergency shutdown & there should be no funding rate updates after the shutdown.
     * If the contract is emergency shutdown then all token holders and sponsors can redeem their tokens or remaining collateral for underlying at the prevailing price defined by a DVM vote.
     */
    settleEmergencyShutdown(): NonPayableTransactionObject<[string]>;

    timerAddress(): NonPayableTransactionObject<string>;

    /**
     * Get emergency shutdown price
     */
    tokenCurrency(): NonPayableTransactionObject<string>;

    /**
     * Accessor method for the total collateral stored within the PerpetualPositionManager.
     */
    totalPositionCollateral(): NonPayableTransactionObject<[string]>;

    /**
     * This will drain down to the amount of tracked collateral and drain the full balance of any other token.
     * Drains any excess balance of the provided ERC20 token to a pre-selected beneficiary.
     * @param token address of the ERC20 token whose excess balance should be drained.
     */
    trimExcess(token: string): NonPayableTransactionObject<[string]>;

    withdraw(
      collateralAmount: [number | string]
    ): NonPayableTransactionObject<[string]>;

    /**
     * Might not withdraw the full requested amount in order to account for precision loss or if the full requested amount exceeds the collateral in the position (due to paying fees).
     * After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.
     */
    withdrawPassedRequest(): NonPayableTransactionObject<[string]>;

    createLiquidation(
      sponsor: string,
      minCollateralPerToken: [number | string],
      maxCollateralPerToken: [number | string],
      maxTokensToLiquidate: [number | string],
      deadline: number | string
    ): NonPayableTransactionObject<{
      liquidationId: string;
      tokensLiquidated: [string];
      finalFeeBond: [string];
      0: string;
      1: [string];
      2: [string];
    }>;

    /**
     * Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes. This contract must be approved to spend at least the dispute bond amount of `feePayerData.collateralCurrency`. This dispute bond amount is calculated from `disputeBondPct` times the collateral in the liquidation.
     * Disputes a liquidation, if the caller has enough collateral to post a dispute bond and pay a fixed final fee charged on each price request.
     * @param liquidationId of the disputed liquidation.
     * @param sponsor the address of the sponsor whose liquidation is being disputed.
     */
    dispute(
      liquidationId: number | string,
      sponsor: string
    ): NonPayableTransactionObject<[string]>;

    /**
     * If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment. If the dispute FAILED: only the liquidator receives payment. This method deletes the liquidation data. This method will revert if rewards have already been dispersed.
     * After a dispute has settled or after a non-disputed liquidation has expired, anyone can call this method to disperse payments to the sponsor, liquidator, and disputer.
     * @param liquidationId uniquely identifies the sponsor's liquidation.
     * @param sponsor address of the sponsor associated with the liquidation.
     */
    withdrawLiquidation(
      liquidationId: number | string,
      sponsor: string
    ): NonPayableTransactionObject<
      [[string], [string], [string], [string], [string], [string]]
    >;

    /**
     * Delete liquidation of a TokenSponsor (This function can only be called by the contract itself)
     * @param liquidationId id of the liquidation.
     * @param sponsor address of the TokenSponsor.
     */
    deleteLiquidation(
      liquidationId: number | string,
      sponsor: string
    ): NonPayableTransactionObject<void>;
  };
  events: {
    Deposit(cb?: Callback<Deposit>): EventEmitter;
    Deposit(options?: EventOptions, cb?: Callback<Deposit>): EventEmitter;

    DisputeSettled(cb?: Callback<DisputeSettled>): EventEmitter;
    DisputeSettled(
      options?: EventOptions,
      cb?: Callback<DisputeSettled>
    ): EventEmitter;

    EmergencyShutdown(cb?: Callback<EmergencyShutdown>): EventEmitter;
    EmergencyShutdown(
      options?: EventOptions,
      cb?: Callback<EmergencyShutdown>
    ): EventEmitter;

    EndedSponsorPosition(cb?: Callback<EndedSponsorPosition>): EventEmitter;
    EndedSponsorPosition(
      options?: EventOptions,
      cb?: Callback<EndedSponsorPosition>
    ): EventEmitter;

    FinalFeesPaid(cb?: Callback<FinalFeesPaid>): EventEmitter;
    FinalFeesPaid(
      options?: EventOptions,
      cb?: Callback<FinalFeesPaid>
    ): EventEmitter;

    LiquidationCreated(cb?: Callback<LiquidationCreated>): EventEmitter;
    LiquidationCreated(
      options?: EventOptions,
      cb?: Callback<LiquidationCreated>
    ): EventEmitter;

    LiquidationDisputed(cb?: Callback<LiquidationDisputed>): EventEmitter;
    LiquidationDisputed(
      options?: EventOptions,
      cb?: Callback<LiquidationDisputed>
    ): EventEmitter;

    LiquidationWithdrawn(cb?: Callback<LiquidationWithdrawn>): EventEmitter;
    LiquidationWithdrawn(
      options?: EventOptions,
      cb?: Callback<LiquidationWithdrawn>
    ): EventEmitter;

    NewSponsor(cb?: Callback<NewSponsor>): EventEmitter;
    NewSponsor(options?: EventOptions, cb?: Callback<NewSponsor>): EventEmitter;

    PositionCreated(cb?: Callback<PositionCreated>): EventEmitter;
    PositionCreated(
      options?: EventOptions,
      cb?: Callback<PositionCreated>
    ): EventEmitter;

    Redeem(cb?: Callback<Redeem>): EventEmitter;
    Redeem(options?: EventOptions, cb?: Callback<Redeem>): EventEmitter;

    RegularFeesPaid(cb?: Callback<RegularFeesPaid>): EventEmitter;
    RegularFeesPaid(
      options?: EventOptions,
      cb?: Callback<RegularFeesPaid>
    ): EventEmitter;

    Repay(cb?: Callback<Repay>): EventEmitter;
    Repay(options?: EventOptions, cb?: Callback<Repay>): EventEmitter;

    RequestWithdrawal(cb?: Callback<RequestWithdrawal>): EventEmitter;
    RequestWithdrawal(
      options?: EventOptions,
      cb?: Callback<RequestWithdrawal>
    ): EventEmitter;

    RequestWithdrawalCanceled(
      cb?: Callback<RequestWithdrawalCanceled>
    ): EventEmitter;
    RequestWithdrawalCanceled(
      options?: EventOptions,
      cb?: Callback<RequestWithdrawalCanceled>
    ): EventEmitter;

    RequestWithdrawalExecuted(
      cb?: Callback<RequestWithdrawalExecuted>
    ): EventEmitter;
    RequestWithdrawalExecuted(
      options?: EventOptions,
      cb?: Callback<RequestWithdrawalExecuted>
    ): EventEmitter;

    RoleAdminChanged(cb?: Callback<RoleAdminChanged>): EventEmitter;
    RoleAdminChanged(
      options?: EventOptions,
      cb?: Callback<RoleAdminChanged>
    ): EventEmitter;

    RoleGranted(cb?: Callback<RoleGranted>): EventEmitter;
    RoleGranted(
      options?: EventOptions,
      cb?: Callback<RoleGranted>
    ): EventEmitter;

    RoleRevoked(cb?: Callback<RoleRevoked>): EventEmitter;
    RoleRevoked(
      options?: EventOptions,
      cb?: Callback<RoleRevoked>
    ): EventEmitter;

    SettleEmergencyShutdown(
      cb?: Callback<SettleEmergencyShutdown>
    ): EventEmitter;
    SettleEmergencyShutdown(
      options?: EventOptions,
      cb?: Callback<SettleEmergencyShutdown>
    ): EventEmitter;

    Withdrawal(cb?: Callback<Withdrawal>): EventEmitter;
    Withdrawal(options?: EventOptions, cb?: Callback<Withdrawal>): EventEmitter;

    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };

  once(event: "Deposit", cb: Callback<Deposit>): void;
  once(event: "Deposit", options: EventOptions, cb: Callback<Deposit>): void;

  once(event: "DisputeSettled", cb: Callback<DisputeSettled>): void;
  once(
    event: "DisputeSettled",
    options: EventOptions,
    cb: Callback<DisputeSettled>
  ): void;

  once(event: "EmergencyShutdown", cb: Callback<EmergencyShutdown>): void;
  once(
    event: "EmergencyShutdown",
    options: EventOptions,
    cb: Callback<EmergencyShutdown>
  ): void;

  once(event: "EndedSponsorPosition", cb: Callback<EndedSponsorPosition>): void;
  once(
    event: "EndedSponsorPosition",
    options: EventOptions,
    cb: Callback<EndedSponsorPosition>
  ): void;

  once(event: "FinalFeesPaid", cb: Callback<FinalFeesPaid>): void;
  once(
    event: "FinalFeesPaid",
    options: EventOptions,
    cb: Callback<FinalFeesPaid>
  ): void;

  once(event: "LiquidationCreated", cb: Callback<LiquidationCreated>): void;
  once(
    event: "LiquidationCreated",
    options: EventOptions,
    cb: Callback<LiquidationCreated>
  ): void;

  once(event: "LiquidationDisputed", cb: Callback<LiquidationDisputed>): void;
  once(
    event: "LiquidationDisputed",
    options: EventOptions,
    cb: Callback<LiquidationDisputed>
  ): void;

  once(event: "LiquidationWithdrawn", cb: Callback<LiquidationWithdrawn>): void;
  once(
    event: "LiquidationWithdrawn",
    options: EventOptions,
    cb: Callback<LiquidationWithdrawn>
  ): void;

  once(event: "NewSponsor", cb: Callback<NewSponsor>): void;
  once(
    event: "NewSponsor",
    options: EventOptions,
    cb: Callback<NewSponsor>
  ): void;

  once(event: "PositionCreated", cb: Callback<PositionCreated>): void;
  once(
    event: "PositionCreated",
    options: EventOptions,
    cb: Callback<PositionCreated>
  ): void;

  once(event: "Redeem", cb: Callback<Redeem>): void;
  once(event: "Redeem", options: EventOptions, cb: Callback<Redeem>): void;

  once(event: "RegularFeesPaid", cb: Callback<RegularFeesPaid>): void;
  once(
    event: "RegularFeesPaid",
    options: EventOptions,
    cb: Callback<RegularFeesPaid>
  ): void;

  once(event: "Repay", cb: Callback<Repay>): void;
  once(event: "Repay", options: EventOptions, cb: Callback<Repay>): void;

  once(event: "RequestWithdrawal", cb: Callback<RequestWithdrawal>): void;
  once(
    event: "RequestWithdrawal",
    options: EventOptions,
    cb: Callback<RequestWithdrawal>
  ): void;

  once(
    event: "RequestWithdrawalCanceled",
    cb: Callback<RequestWithdrawalCanceled>
  ): void;
  once(
    event: "RequestWithdrawalCanceled",
    options: EventOptions,
    cb: Callback<RequestWithdrawalCanceled>
  ): void;

  once(
    event: "RequestWithdrawalExecuted",
    cb: Callback<RequestWithdrawalExecuted>
  ): void;
  once(
    event: "RequestWithdrawalExecuted",
    options: EventOptions,
    cb: Callback<RequestWithdrawalExecuted>
  ): void;

  once(event: "RoleAdminChanged", cb: Callback<RoleAdminChanged>): void;
  once(
    event: "RoleAdminChanged",
    options: EventOptions,
    cb: Callback<RoleAdminChanged>
  ): void;

  once(event: "RoleGranted", cb: Callback<RoleGranted>): void;
  once(
    event: "RoleGranted",
    options: EventOptions,
    cb: Callback<RoleGranted>
  ): void;

  once(event: "RoleRevoked", cb: Callback<RoleRevoked>): void;
  once(
    event: "RoleRevoked",
    options: EventOptions,
    cb: Callback<RoleRevoked>
  ): void;

  once(
    event: "SettleEmergencyShutdown",
    cb: Callback<SettleEmergencyShutdown>
  ): void;
  once(
    event: "SettleEmergencyShutdown",
    options: EventOptions,
    cb: Callback<SettleEmergencyShutdown>
  ): void;

  once(event: "Withdrawal", cb: Callback<Withdrawal>): void;
  once(
    event: "Withdrawal",
    options: EventOptions,
    cb: Callback<Withdrawal>
  ): void;
}
