/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "./types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export type EncryptedVote = ContractEventLog<{
  voter: string;
  roundId: string;
  identifier: string;
  time: string;
  ancillaryData: string;
  encryptedVote: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
  5: string;
}>;
export type OwnershipTransferred = ContractEventLog<{
  previousOwner: string;
  newOwner: string;
  0: string;
  1: string;
}>;
export type PriceRequestAdded = ContractEventLog<{
  roundId: string;
  identifier: string;
  time: string;
  0: string;
  1: string;
  2: string;
}>;
export type PriceResolved = ContractEventLog<{
  roundId: string;
  identifier: string;
  time: string;
  price: string;
  ancillaryData: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
}>;
export type RewardsRetrieved = ContractEventLog<{
  voter: string;
  roundId: string;
  identifier: string;
  time: string;
  ancillaryData: string;
  numTokens: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
  5: string;
}>;
export type VoteCommitted = ContractEventLog<{
  voter: string;
  roundId: string;
  identifier: string;
  time: string;
  ancillaryData: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
}>;
export type VoteRevealed = ContractEventLog<{
  voter: string;
  roundId: string;
  identifier: string;
  time: string;
  price: string;
  ancillaryData: string;
  numTokens: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
  5: string;
  6: string;
}>;

export interface Voting extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): Voting;
  clone(): Voting;
  methods: {
    ancillaryBytesLimit(): NonPayableTransactionObject<string>;

    gatPercentage(): NonPayableTransactionObject<string>;

    /**
     * Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp.
     */
    getCurrentTime(): NonPayableTransactionObject<string>;

    inflationRate(): NonPayableTransactionObject<string>;

    migratedAddress(): NonPayableTransactionObject<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(): NonPayableTransactionObject<string>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(): NonPayableTransactionObject<void>;

    rewardsExpirationTimeout(): NonPayableTransactionObject<string>;

    rounds(
      arg0: number | string
    ): NonPayableTransactionObject<{
      snapshotId: string;
      inflationRate: [string];
      gatPercentage: [string];
      rewardsExpirationTime: string;
      0: string;
      1: [string];
      2: [string];
      3: string;
    }>;

    /**
     * Will revert if not running in test mode.
     * Sets the current time.
     * @param time timestamp to set current Testable time to.
     */
    setCurrentTime(time: number | string): NonPayableTransactionObject<void>;

    snapshotMessageHash(): NonPayableTransactionObject<string>;

    timerAddress(): NonPayableTransactionObject<string>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(newOwner: string): NonPayableTransactionObject<void>;

    voteTiming(): NonPayableTransactionObject<string>;

    votingToken(): NonPayableTransactionObject<string>;

    /**
     * Time must be in the past and the identifier must be supported. The length of the ancillary data is limited such that this method abides by the EVM transaction gas limit.
     * Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.
     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.
     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.
     * @param time unix timestamp for the price request.
     */
    "requestPrice(bytes32,uint256,bytes)"(
      identifier: string | number[],
      time: number | string,
      ancillaryData: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * Time must be in the past and the identifier must be supported.
     * Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.
     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.
     * @param time unix timestamp for the price request.
     */
    "requestPrice(bytes32,uint256)"(
      identifier: string | number[],
      time: number | string
    ): NonPayableTransactionObject<void>;

    /**
     * Time must be in the past and the identifier must be supported.
     * Whether the price for `identifier` and `time` is available.
     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.
     * @param time unix timestamp for the price request.
     */
    "hasPrice(bytes32,uint256)"(
      identifier: string | number[],
      time: number | string
    ): NonPayableTransactionObject<boolean>;

    /**
     * Time must be in the past and the identifier must be supported.
     * Whether the price for `identifier` and `time` is available.
     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.
     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.
     * @param time unix timestamp of for the price request.
     */
    "hasPrice(bytes32,uint256,bytes)"(
      identifier: string | number[],
      time: number | string,
      ancillaryData: string | number[]
    ): NonPayableTransactionObject<boolean>;

    /**
     * If the price is not available, the method reverts.
     * Gets the price for `identifier` and `time` if it has already been requested and resolved.
     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.
     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.
     * @param time unix timestamp of for the price request.
     */
    "getPrice(bytes32,uint256,bytes)"(
      identifier: string | number[],
      time: number | string,
      ancillaryData: string | number[]
    ): NonPayableTransactionObject<string>;

    /**
     * If the price is not available, the method reverts.
     * Gets the price for `identifier` and `time` if it has already been requested and resolved.
     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.
     * @param time unix timestamp for the price request.
     */
    "getPrice(bytes32,uint256)"(
      identifier: string | number[],
      time: number | string
    ): NonPayableTransactionObject<string>;

    "getPriceRequestStatuses(tuple[])"(
      requests: [string | number[], number | string, string | number[]][]
    ): NonPayableTransactionObject<[string, string][]>;

    "getPriceRequestStatuses(tuple[])"(
      requests: [string | number[], number | string][]
    ): NonPayableTransactionObject<[string, string][]>;

    /**
     * `identifier`, `time` must correspond to a price request that's currently in the commit phase. Commits can be changed.Since transaction data is public, the salt will be revealed with the vote. While this is the system’s expected behavior, voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then they can determine the vote pre-reveal.
     * Commit a vote for a price request for `identifier` at `time`.
     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.
     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.
     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.
     * @param time unix timestamp of the price being voted on.
     */
    "commitVote(bytes32,uint256,bytes,bytes32)"(
      identifier: string | number[],
      time: number | string,
      ancillaryData: string | number[],
      hash: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * `identifier`, `time` must correspond to a price request that's currently in the commit phase. Commits can be changed.Since transaction data is public, the salt will be revealed with the vote. While this is the system’s expected behavior, voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then they can determine the vote pre-reveal.
     * Commit a vote for a price request for `identifier` at `time`.
     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.
     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.
     * @param time unix timestamp of the price being voted on.
     */
    "commitVote(bytes32,uint256,bytes32)"(
      identifier: string | number[],
      time: number | string,
      hash: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * This function can be called multiple times, but only the first call per round into this function or `revealVote` will create the round snapshot. Any later calls will be a no-op. Will revert unless called during reveal period.
     * Snapshot the current round's token balances and lock in the inflation rate and GAT.
     * @param signature signature required to prove caller is an EOA to prevent flash loans from being included in the snapshot.
     */
    snapshotCurrentRound(
      signature: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash` that `commitVote()` was called with. Only the committer can reveal their vote.
     * Reveal a previously committed vote for `identifier` at `time`.
     * @param identifier voted on in the commit phase. EG BTC/USD price pair.
     * @param price voted on during the commit phase.
     * @param salt value used to hide the commitment price during the commit phase.
     * @param time specifies the unix timestamp of the price is being voted on.
     */
    "revealVote(bytes32,uint256,int256,int256)"(
      identifier: string | number[],
      time: number | string,
      price: number | string,
      salt: number | string
    ): NonPayableTransactionObject<void>;

    /**
     * The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash` that `commitVote()` was called with. Only the committer can reveal their vote.
     * Reveal a previously committed vote for `identifier` at `time`.
     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.
     * @param identifier voted on in the commit phase. EG BTC/USD price pair.
     * @param price voted on during the commit phase.
     * @param salt value used to hide the commitment price during the commit phase.
     * @param time specifies the unix timestamp of the price being voted on.
     */
    "revealVote(bytes32,uint256,int256,bytes,int256)"(
      identifier: string | number[],
      time: number | string,
      price: number | string,
      ancillaryData: string | number[],
      salt: number | string
    ): NonPayableTransactionObject<void>;

    /**
     * An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.
     * commits a vote and logs an event with a data blob, typically an encrypted version of the vote
     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.
     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.
     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.
     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.
     * @param time unix timestamp of for the price request.
     */
    "commitAndEmitEncryptedVote(bytes32,uint256,bytes,bytes32,bytes)"(
      identifier: string | number[],
      time: number | string,
      ancillaryData: string | number[],
      hash: string | number[],
      encryptedVote: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.
     * commits a vote and logs an event with a data blob, typically an encrypted version of the vote
     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.
     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.
     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.
     * @param time unix timestamp of for the price request.
     */
    "commitAndEmitEncryptedVote(bytes32,uint256,bytes32,bytes)"(
      identifier: string | number[],
      time: number | string,
      hash: string | number[],
      encryptedVote: string | number[]
    ): NonPayableTransactionObject<void>;

    "batchCommit(tuple[])"(
      commits: [
        string | number[],
        number | string,
        string | number[],
        string | number[],
        string | number[]
      ][]
    ): NonPayableTransactionObject<void>;

    "batchCommit(tuple[])"(
      commits: [
        string | number[],
        number | string,
        string | number[],
        string | number[]
      ][]
    ): NonPayableTransactionObject<void>;

    "batchReveal(tuple[])"(
      reveals: [
        string | number[],
        number | string,
        number | string,
        number | string
      ][]
    ): NonPayableTransactionObject<void>;

    "batchReveal(tuple[])"(
      reveals: [
        string | number[],
        number | string,
        number | string,
        string | number[],
        number | string
      ][]
    ): NonPayableTransactionObject<void>;

    "retrieveRewards(address,uint256,tuple[])"(
      voterAddress: string,
      roundId: number | string,
      toRetrieve: [string | number[], number | string, string | number[]][]
    ): NonPayableTransactionObject<[string]>;

    "retrieveRewards(address,uint256,tuple[])"(
      voterAddress: string,
      roundId: number | string,
      toRetrieve: [string | number[], number | string][]
    ): NonPayableTransactionObject<[string]>;

    /**
     * Gets the queries that are being voted on this round.
     */
    getPendingRequests(): NonPayableTransactionObject<
      [string, string, string][]
    >;

    /**
     * Returns the current voting phase, as a function of the current time.
     */
    getVotePhase(): NonPayableTransactionObject<string>;

    /**
     * Returns the current round ID, as a function of the current time.
     */
    getCurrentRoundId(): NonPayableTransactionObject<string>;

    /**
     * Can only be called by the contract owner.
     * Disables this Voting contract in favor of the migrated one.
     * @param newVotingAddress the newly migrated contract address.
     */
    setMigrated(newVotingAddress: string): NonPayableTransactionObject<void>;

    setInflationRate(
      newInflationRate: [number | string]
    ): NonPayableTransactionObject<void>;

    setGatPercentage(
      newGatPercentage: [number | string]
    ): NonPayableTransactionObject<void>;

    /**
     * This change only applies to rounds that have not yet begun.
     * Resets the rewards expiration timeout.
     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.
     */
    setRewardsExpirationTimeout(
      NewRewardsExpirationTimeout: number | string
    ): NonPayableTransactionObject<void>;
  };
  events: {
    EncryptedVote(cb?: Callback<EncryptedVote>): EventEmitter;
    EncryptedVote(
      options?: EventOptions,
      cb?: Callback<EncryptedVote>
    ): EventEmitter;

    OwnershipTransferred(cb?: Callback<OwnershipTransferred>): EventEmitter;
    OwnershipTransferred(
      options?: EventOptions,
      cb?: Callback<OwnershipTransferred>
    ): EventEmitter;

    PriceRequestAdded(cb?: Callback<PriceRequestAdded>): EventEmitter;
    PriceRequestAdded(
      options?: EventOptions,
      cb?: Callback<PriceRequestAdded>
    ): EventEmitter;

    PriceResolved(cb?: Callback<PriceResolved>): EventEmitter;
    PriceResolved(
      options?: EventOptions,
      cb?: Callback<PriceResolved>
    ): EventEmitter;

    RewardsRetrieved(cb?: Callback<RewardsRetrieved>): EventEmitter;
    RewardsRetrieved(
      options?: EventOptions,
      cb?: Callback<RewardsRetrieved>
    ): EventEmitter;

    VoteCommitted(cb?: Callback<VoteCommitted>): EventEmitter;
    VoteCommitted(
      options?: EventOptions,
      cb?: Callback<VoteCommitted>
    ): EventEmitter;

    VoteRevealed(cb?: Callback<VoteRevealed>): EventEmitter;
    VoteRevealed(
      options?: EventOptions,
      cb?: Callback<VoteRevealed>
    ): EventEmitter;

    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };

  once(event: "EncryptedVote", cb: Callback<EncryptedVote>): void;
  once(
    event: "EncryptedVote",
    options: EventOptions,
    cb: Callback<EncryptedVote>
  ): void;

  once(event: "OwnershipTransferred", cb: Callback<OwnershipTransferred>): void;
  once(
    event: "OwnershipTransferred",
    options: EventOptions,
    cb: Callback<OwnershipTransferred>
  ): void;

  once(event: "PriceRequestAdded", cb: Callback<PriceRequestAdded>): void;
  once(
    event: "PriceRequestAdded",
    options: EventOptions,
    cb: Callback<PriceRequestAdded>
  ): void;

  once(event: "PriceResolved", cb: Callback<PriceResolved>): void;
  once(
    event: "PriceResolved",
    options: EventOptions,
    cb: Callback<PriceResolved>
  ): void;

  once(event: "RewardsRetrieved", cb: Callback<RewardsRetrieved>): void;
  once(
    event: "RewardsRetrieved",
    options: EventOptions,
    cb: Callback<RewardsRetrieved>
  ): void;

  once(event: "VoteCommitted", cb: Callback<VoteCommitted>): void;
  once(
    event: "VoteCommitted",
    options: EventOptions,
    cb: Callback<VoteCommitted>
  ): void;

  once(event: "VoteRevealed", cb: Callback<VoteRevealed>): void;
  once(
    event: "VoteRevealed",
    options: EventOptions,
    cb: Callback<VoteRevealed>
  ): void;
}
